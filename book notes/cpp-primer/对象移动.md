1. 右值引用（rvalue reference）
(1) 定义：必须绑定到右值的引用，通过&&而不是&来获得右值引用；
(2) 说明：1) 只能绑定到一个将要销毁的对象；                                                   int &&r = 42;
                2) 不能直接绑定到一个左值上;                                                             int i = 42;  int &&r = i(错误)；
                3) 可以将一个const的左值绑定到右值上;                                             const int &r = i;
                4) 不能绑定到一个右值引用类型的变量上；                                         int &&rr1 = 42; int &&rr2 = rr1(错误，表达式rr1是左值)；
                5) 变量是左值
(3) 返回右值的情况：1) 非引用类型的函数；2) 算术、关系、位以及后置递增/递减运算符；
(4) 特性：1) 所引用的对象将要被销毁；2) 该对象没有其他用户；
(5) 标准库move函数：获得绑定到左值上的右值引用，int &&rr3 = std::move(rr1), 
                                     move调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它；
                                     调用move则意味着承诺：除了对rr1赋值或销毁它外，我们将不再使用它
2. 移动构造函数和移动赋值运算符
(1) 说明：1) 类似对应的拷贝动作，但它们从给定对象“窃取”资源而不是拷贝资源；
                2) 移动构造函数的第一个参数是该类型的一个右值引用，任何额外的参数都必须有默认实参；
                3) 除了完成资源移动，移动构造函数还必须确保移后源对象处于销毁无害的状态；特别是，一旦资源完成移动，源对象必须
                    不再指向被移动的资源-----这些资源的所有权已经归属新创建的对象；
                4) 与拷贝构造函数不同，移动构造函数不分配任何新内存；
                5) 移动操作通常不会抛出任何异常，因此我们在移动函数中指明noexcept，避免一些额外的工作；
(2) 合成的移动操作
1) 只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数
    或移动赋值运算符。编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员
2) 移动操作永远不会隐式定义为删除的函数；
3) 以下情况，编译器会将移动操作定义为删除的函数：
    a) 有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数；
    b) 有类成员的移动构造函数或移动或移动赋值运算符被定义为删除的或是不可访问的；
    c)  类的析构函数被定义为删除或不可访问的；
    d) 类成员是const的或是引用；
4) 如果一个类定义了一个移动构造函数和/或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的；
    因此，定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作，否则，这些成员默认被定义成删除的。
5) 如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数；